#!/usr/bin/env bash
# Jellyfin Tizen Auto-Installer
# Works WITHOUT Tizen Studio for Developer Mode TVs
set -euo pipefail
IFS=$'\n\t'

# ==========================
# CONFIGURATION
# ==========================
REPO="jeppevinkel/jellyfin-tizen-builds"
DOCKER_IMG="ghcr.io/georift/install-jellyfin-tizen:latest"
MAX_RETRIES=3
CACHE_DIR="${HOME:-$PWD}/.jellyfin-tizen-cache"
TMP_LOG="/tmp/jellyfin_install.log.$$"
CURL_OPTS="-fsSL"   # fail on HTTP errors, show errors, follow redirects
JQ_BIN="$(command -v jq || true)"
INTERACTIVE=true

# COLORS (fallback to empty if no tty)
if [ -t 2 ]; then
  RED=$'\033[0;31m'; GREEN=$'\033[0;32m'; YELLOW=$'\033[1;33m'; BLUE=$'\033[0;34m'; NC=$'\033[0m'
else
  RED=''; GREEN=''; YELLOW=''; BLUE=''; NC=''
fi

print_status()  { echo -e "${BLUE}[INFO]${NC} $1" >&2; }
print_success() { echo -e "${GREEN}[OK]${NC} $1" >&2; }
print_warning() { echo -e "${YELLOW}[WARN]${NC} $1" >&2; }
print_error()   { echo -e "${RED}[ERROR]${NC} $1" >&2; }

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --non-interactive)
      INTERACTIVE=false
      shift
      ;;
    -h|--help)
      echo "Usage: $0 [--non-interactive]"
      echo "  --non-interactive: Run without user prompts (selects first available options)"
      exit 0
      ;;
    *)
      print_error "Unknown option: $1"
      exit 1
      ;;
  esac
done

# Portable timeout function
portable_timeout() {
  local duration=$1; shift
  if command -v timeout >/dev/null 2>&1; then
    timeout "$duration" "$@"
  elif command -v gtimeout >/dev/null 2>&1; then
    gtimeout "$duration" "$@"
  else
    # Fallback without timeout (may hang)
    print_warning "No timeout command available - this operation may hang indefinitely"
    print_warning "Consider installing 'timeout' command or run with Ctrl+C to abort"
    "$@"
  fi
}

# Enhanced connectivity check using TCP port test
check_tv_connectivity() {
  local host=$1
  local port=${2:-26101}
  
  # Try netcat first (most reliable for port checking)
  if command -v nc >/dev/null 2>&1; then
    if nc -z -w 3 "$host" "$port" 2>/dev/null; then
      return 0
    fi
  # Try telnet as fallback
  elif command -v telnet >/dev/null 2>&1; then
    if echo "" | portable_timeout 3s telnet "$host" "$port" 2>/dev/null | grep -q "Connected"; then
      return 0
    fi
  # Fallback to ping (less reliable for service check)
  else
    print_warning "No nc/telnet available - falling back to ping (less reliable)"
    if [[ "$(uname -s)" == "Darwin" ]]; then
      # macOS ping: -c count -t timeout_seconds
      ping -c 1 -t 2 "$host" >/dev/null 2>&1
    else
      # Linux ping: -c count -W timeout_seconds  
      ping -c 1 -W 2 "$host" >/dev/null 2>&1
    fi
  fi
}

mkdir -p "$CACHE_DIR"

# ensure cleanup
cleanup() {
  rm -f "$TMP_LOG"
}
trap cleanup EXIT INT TERM

# ==========================
# 1. Ensure Docker is available & usable
# ==========================
if ! command -v docker &>/dev/null; then
    print_error "Docker is not installed!"
    print_error "Install with: sudo apt update && sudo apt install docker.io (or use Docker Desktop)"
    exit 1
fi

# check docker can be run by this user
if ! docker info >/dev/null 2>&1; then
    print_error "Docker isn't usable by this user (permission or daemon issue)."
    print_error "Try: sudo usermod -aG docker \$USER && newgrp docker"
    print_error "Or run this script with sudo (not recommended for security)"
    exit 1
fi

# ==========================
# 2. Fetch available Jellyfin builds with enhanced error handling
# ==========================
print_status "Fetching available Jellyfin builds from GitHub API..."
api_url="https://api.github.com/repos/$REPO/releases/latest"
http_response="$(mktemp)" || {
  print_error "Failed to create temporary file"
  exit 1
}

# Enhanced HTTP status checking
if ! curl $CURL_OPTS -H "Accept: application/vnd.github.v3+json" -w "%{http_code}" -o "$http_response" "$api_url" > "${http_response}.status"; then
    print_error "Failed to fetch release info from $api_url"
    rm -f "$http_response" "${http_response}.status"
    exit 1
fi

http_status="$(cat "${http_response}.status")"
rm -f "${http_response}.status"

case "$http_status" in
  200)
    print_success "Successfully fetched release information"
    ;;
  403)
    print_error "GitHub API rate limit exceeded (HTTP 403)"
    print_error "Please wait an hour or authenticate with GitHub API"
    rm -f "$http_response"
    exit 1
    ;;
  404)
    print_error "Repository not found (HTTP 404): $REPO"
    rm -f "$http_response"
    exit 1
    ;;
  *)
    print_error "Unexpected HTTP status: $http_status"
    print_error "GitHub API might be temporarily unavailable"
    rm -f "$http_response"
    exit 1
    ;;
esac

if [ -n "$JQ_BIN" ]; then
  LATEST_TAG="$(jq -r '.tag_name // empty' "$http_response")"
  mapfile -t available_builds < <(jq -r '.assets[]?.browser_download_url | select(endswith(".wgt"))' "$http_response")
else
  LATEST_TAG="$(grep -m1 '"tag_name"' "$http_response" | sed -E 's/.*"tag_name": *"([^"]+)".*/\1/')"
  mapfile -t available_builds < <(grep "browser_download_url" "$http_response" | grep ".wgt" | cut -d '"' -f4)
fi
rm -f "$http_response"

if [ -z "${LATEST_TAG:-}" ]; then
  print_error "Couldn't determine latest tag from API response"
  exit 1
fi

if [ ${#available_builds[@]} -eq 0 ]; then
  print_error "No Jellyfin .wgt builds found in release $LATEST_TAG"
  exit 1
fi

# List builds and let user choose
echo
print_status "Available Jellyfin builds for $LATEST_TAG:"
for i in "${!available_builds[@]}"; do
  build_name="$(basename "${available_builds[$i]}")"
  desc=""
  [[ "$build_name" == *"TrueHD"* ]] && desc=" (TrueHD audio support)"
  [[ "$build_name" == *"GrayFix"* ]] && desc=" (Gray theme fix)"
  [[ "$build_name" == *"OblongIcon"* ]] && desc=" (Oblong icon)"
  [[ "$build_name" == *"secondary"* ]] && desc=" (Secondary app for multiple accounts)"
  echo "  $((i+1)). $build_name$desc"
done

selected_index=0
if [ "$INTERACTIVE" = true ] && [ ${#available_builds[@]} -gt 1 ]; then
  while true; do
    read -r -p "Select build number (1-${#available_builds[@]}): " choice
    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#available_builds[@]} ]; then
      selected_index=$((choice-1))
      break
    else
      print_error "Invalid choice"
    fi
  done
else
  print_status "Using first available build (non-interactive mode or single option)"
fi

JELLYFIN_URL="${available_builds[$selected_index]}"
JELLYFIN_FILE="$(basename "$JELLYFIN_URL")"
CACHED_FILE="$CACHE_DIR/$JELLYFIN_FILE"

# ==========================
# 3. Cache the .wgt file with enhanced validation
# ==========================
if [ ! -f "$CACHED_FILE" ]; then
  print_status "Downloading $JELLYFIN_FILE..."
  print_status "Download URL: $JELLYFIN_URL"
  if ! curl $CURL_OPTS -o "$CACHED_FILE" "$JELLYFIN_URL"; then
    print_error "Failed to download $JELLYFIN_URL"
    rm -f "$CACHED_FILE"
    exit 1
  fi
  
  # Enhanced file validation
  if [ ! -s "$CACHED_FILE" ]; then
    print_error "Downloaded file is empty"
    rm -f "$CACHED_FILE"
    exit 1
  fi
  
  # Check if file looks like a ZIP/WGT (basic magic number check)
  if command -v file >/dev/null 2>&1; then
    file_type=$(file -b "$CACHED_FILE")
    if [[ ! "$file_type" =~ (Zip|ZIP|archive) ]]; then
      print_warning "Downloaded file may not be a valid .wgt archive: $file_type"
    fi
  fi
  
  # Cross-platform file size detection
  if command -v stat >/dev/null 2>&1; then
    if [[ "$(uname -s)" == "Darwin" ]]; then
      file_size=$(stat -f%z "$CACHED_FILE" 2>/dev/null || echo "unknown")
    else
      file_size=$(stat -c%s "$CACHED_FILE" 2>/dev/null || echo "unknown")
    fi
  else
    file_size="unknown"
  fi
  
  # Basic size sanity check (WGT files should be at least 1MB)
  if [[ "$file_size" =~ ^[0-9]+$ ]] && [ "$file_size" -lt 1048576 ]; then
    print_warning "Downloaded file seems unusually small ($file_size bytes) for a Jellyfin app"
  fi
  
  print_success "Downloaded $JELLYFIN_FILE (${file_size} bytes)"
else
  print_status "Using cached build: $JELLYFIN_FILE"
fi
print_success "Ready to install: $JELLYFIN_FILE"

# ==========================
# 4. Enhanced Samsung TV discovery
# ==========================
print_status "Scanning for Samsung TVs..."

tv_ips=()
print_status "Determining local network(s)..."

# Try to extract local CIDRs using `ip` first (Linux). Fallback to common networks
mapfile -t local_nets < <(
  if command -v ip >/dev/null 2>&1; then
    ip -o -4 addr show scope global 2>/dev/null \
      | awk '{print $4}' \
      | grep -E '^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)' || true
  else
    # fallback: try ifconfig (macOS/BSD)
    if command -v ifconfig >/dev/null 2>&1; then
      ifconfig 2>/dev/null \
        | awk '/inet /{gsub(/addr:/, "", $2); print $2"/24"}' \
        | grep -E '^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)' || true
    fi
  fi
)

if [ ${#local_nets[@]} -eq 0 ]; then
  print_warning "Couldn't detect local networks automatically; trying common ranges"
  local_nets=("192.168.1.0/24" "192.168.0.0/24" "10.0.0.0/24")
fi

# Choose first network for scanning
target_net="${local_nets[0]}"
print_status "Using network: $target_net"

# nmap check & prompt to install (only in interactive mode)
if ! command -v nmap >/dev/null 2>&1; then
  if [ "$INTERACTIVE" = true ]; then
    read -r -p "nmap is required for fast scanning. Install it? [Y/n]: " do_install_nmap
    if [[ "$do_install_nmap" =~ ^[Nn]$ ]]; then
      print_warning "Skipping scan. You'll be prompted for manual IP."
    else
      print_status "Installing nmap (requires sudo)..."
      if command -v apt >/dev/null 2>&1; then
        sudo apt update && sudo apt install -y nmap
      elif command -v yum >/dev/null 2>&1; then
        sudo yum install -y nmap
      elif command -v brew >/dev/null 2>&1; then
        brew install nmap
      elif command -v apk >/dev/null 2>&1; then
        sudo apk add nmap
      else
        print_error "Please install nmap manually"
        exit 1
      fi
    fi
  else
    print_warning "nmap not available and running in non-interactive mode"
    print_warning "Skipping network scan"
  fi
fi

if command -v nmap >/dev/null 2>&1; then
  print_status "Scanning ${target_net} for Samsung TVs (port 26101)..."
  # Use portable nmap flags that work across versions
  # Add warning about potential hang in non-timeout environments
  if ! command -v timeout >/dev/null 2>&1 && ! command -v gtimeout >/dev/null 2>&1; then
    print_warning "No timeout command available - scan may take longer than expected"
  fi
  
  mapfile -t tv_ips < <(
    portable_timeout 30s nmap -p 26101 --open -n -T4 -Pn --max-retries 1 --host-timeout 8s -oG - "${target_net}" 2>/dev/null \
    | awk '/Host: .*Ports: .*open/{ for(i=1;i<=NF;i++) if($i ~ /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/) print $i }' \
    | sort -u || true
  )
fi

if [ ${#tv_ips[@]} -eq 0 ]; then
  print_warning "No Samsung TVs found on ${target_net}"
  if [ "$INTERACTIVE" = true ]; then
    echo
    print_status "To find your TV IP address:"
    print_status "• Check router admin panel (usually 192.168.1.1 or 192.168.0.1)"
    print_status "• Look for DHCP client list or connected devices"
    print_status "• Check TV: Settings → General → Network → Network Status"
    echo
    read -r -p "Enter TV IP address manually: " manual_ip
    if [[ "$manual_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
      tv_ips=("$manual_ip")
    else
      print_error "Invalid IP format (example: 192.168.1.100)"
      exit 1
    fi
  else
    print_error "No TVs found and running in non-interactive mode"
    print_error "Please run in interactive mode or ensure TV is discoverable"
    exit 1
  fi
fi

print_success "Found ${#tv_ips[@]} TV(s):"
for i in "${!tv_ips[@]}"; do
  echo "  $((i+1)). ${tv_ips[$i]}"
done

# TV selection
selected_ip="${tv_ips[0]}"
if [ "$INTERACTIVE" = true ] && [ ${#tv_ips[@]} -gt 1 ]; then
  while true; do
    read -r -p "Select TV number to install (1-${#tv_ips[@]}): " choice
    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#tv_ips[@]} ]; then
      selected_ip="${tv_ips[$((choice-1))]}"
      break
    else
      print_error "Invalid choice"
    fi
  done
else
  print_status "Using first detected TV (non-interactive mode or single option)"
fi
print_success "Selected TV: $selected_ip"

# Enhanced connectivity check using TCP port test
print_status "Checking TV connectivity on port 26101..."
if check_tv_connectivity "$selected_ip" 26101; then
  print_success "TV service is accessible on port 26101"
else
  print_warning "Cannot connect to TV on port 26101"
  print_warning "TV might be sleeping, firewall blocking, or Developer Mode disabled"
  print_warning "Continuing with installation attempt..."
fi

# ==========================
# 5. Determine package ID
# ==========================
PACKAGE_ID="${JELLYFIN_FILE%.wgt}"
print_status "Using Package ID: $PACKAGE_ID"
RELEASE_URL="https://github.com/$REPO/releases/tag/$LATEST_TAG"
print_status "Release URL: $RELEASE_URL"

# ==========================
# 6. Installation with enhanced OS detection and Docker settings
# ==========================
installation_success=false

# Use uname instead of OSTYPE for better portability
OS_NAME="$(uname -s)"
DOCKER_NET_OPTS=()
case "$OS_NAME" in
  Linux)
    DOCKER_NET_OPTS=(--network host)
    print_status "Using Docker host networking (Linux)"
    ;;
  Darwin)
    print_warning "macOS detected: Using default Docker networking (container ports won't match host)"
    ;;
  *)
    print_warning "Unknown OS ($OS_NAME): Using default Docker networking"
    ;;
esac

for attempt in $(seq 1 $MAX_RETRIES); do
  print_status "Attempt $attempt/$MAX_RETRIES: Installing $JELLYFIN_FILE on $selected_ip..."
  
  # Construct command for display (handle empty DOCKER_NET_OPTS gracefully)
  if [ ${#DOCKER_NET_OPTS[@]} -gt 0 ]; then
    docker_cmd_display="docker run --rm ${DOCKER_NET_OPTS[*]} $DOCKER_IMG $selected_ip \"$PACKAGE_ID\" \"$RELEASE_URL\""
  else
    docker_cmd_display="docker run --rm $DOCKER_IMG $selected_ip \"$PACKAGE_ID\" \"$RELEASE_URL\""
  fi
  print_status "Command: $docker_cmd_display"
  
  if portable_timeout 300s docker run --rm "${DOCKER_NET_OPTS[@]}" "$DOCKER_IMG" "$selected_ip" "$PACKAGE_ID" "$RELEASE_URL" 2>&1 | tee "$TMP_LOG"; then
    # Check for specific success patterns (more restrictive)
    if grep -qiE "(tizen application is successfully installed|install completed|installation.*success)" "$TMP_LOG"; then
      print_success "Installation completed successfully!"
      installation_success=true
      break
    elif grep -qiE "(spend time for wascmd|cmd_ret:0)" "$TMP_LOG" && ! grep -qiE "(fail|error|exception)" "$TMP_LOG"; then
      # Tizen-specific success indicators
      print_success "Installation appears successful (Tizen command completed)"
      installation_success=true
      break
    else
      print_warning "Docker completed but installation status unclear. Check output above."
      print_warning "Look for 'Tizen application is successfully installed' message."
    fi
  else
    docker_exit_code=$?
    print_warning "Docker command failed with exit code: $docker_exit_code"
    if [ $attempt -lt $MAX_RETRIES ]; then
      print_status "Waiting 5 seconds before retry..."
      sleep 5
    fi
  fi
done

if [ "$installation_success" = true ]; then
  print_success "Jellyfin installation process completed!"
  print_status "Check your TV's app list for the Jellyfin app."
  print_status "You may need to restart your TV if the app doesn't appear immediately."
  print_status "If successful, configure your Jellyfin server connection in the app."
  exit 0
fi

# ==========================
# 7. Enhanced failure handling
# ==========================
print_error "All installation attempts failed."
echo
print_error "Troubleshooting steps:"
print_error "1. Verify TV Developer Mode is enabled:"
print_error "   Settings → General → External Device Manager → Developer Mode: ON"
print_error "   (Enter any name when prompted for Developer IP)"
print_error "   Restart your TV after enabling Developer Mode"
echo
print_error "2. Check network connectivity:"
print_error "   Ensure TV and computer are on the same network"
print_error "   Test port access: nc -z $selected_ip 26101"
print_error "   Or telnet: telnet $selected_ip 26101"
echo
print_error "3. Manual installation command:"
if [ ${#DOCKER_NET_OPTS[@]} -gt 0 ]; then
  print_error "   docker run --rm ${DOCKER_NET_OPTS[*]} $DOCKER_IMG \\"
else
  print_error "   docker run --rm $DOCKER_IMG \\"
fi
print_error "     $selected_ip \\"
print_error "     \"$PACKAGE_ID\" \\"
print_error "     \"$RELEASE_URL\""
echo
print_error "4. Try different build:"
print_error "   Run this script again and select a different .wgt file"

if [ -f "$TMP_LOG" ]; then
  echo
  print_error "Last installation log (last 30 lines):"
  tail -n 30 "$TMP_LOG" | sed 's/^/  /' >&2
fi

exit 1
